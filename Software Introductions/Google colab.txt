# PRACTICALS: AGRICULTURE REGRESSION IN PYTHON

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# For regression and diagnostics
import statsmodels.api as sm
import statsmodels.formula.api as smf
from statsmodels.stats.outliers_influence import variance_inflation_factor
from statsmodels.stats.diagnostic import het_breuschpagan, het_white, acorr_breusch_godfrey
from statsmodels.stats.stattools import durbin_watson
from statsmodels.stats.outliers_influence import OLSInfluence
from sklearn.impute import SimpleImputer

# For logit/probit
from statsmodels.discrete.discrete_model import Logit, Probit

# For robust SE
from statsmodels.stats.sandwich_covariance import cov_hc0

# For 2SLS/IV
from linearmodels.iv import IV2SLS

# 1. SIMULATE DATASETS -----------------------------------------

np.random.seed(123)

# Dataset 1: Crop Yield (cross-sectional)
n1 = 200
region = np.random.choice(['North', 'South', 'East', 'West'], n1)
soil_quality = np.random.choice([1, 2, 3], n1)
farmer_edu = np.round(np.random.normal(10, 3, n1))
fertilizer = np.round(np.random.normal(120, 30, n1))
irrigation = np.round(np.random.normal(300, 80, n1))
seed_rate = np.round(np.random.normal(80, 10, n1))
income = np.round(np.random.normal(150000, 20000, n1))
adopt_prob = 1 / (1 + np.exp(-(-2 + 0.1*farmer_edu + 0.00001*income + 0.3*soil_quality)))
adopt_tech = np.random.binomial(1, adopt_prob)
yield_ = (15 + 0.08*fertilizer + 0.04*irrigation + 0.12*seed_rate + 2*soil_quality +
          0.2*farmer_edu + 3*adopt_tech +
          np.where(region=="North", 1, np.where(region=="South", -1, 0)) +
          np.random.normal(0, 5, n1))

agri1 = pd.DataFrame({'Yield': yield_, 'Fertilizer': fertilizer, 'Irrigation': irrigation,
                      'SeedRate': seed_rate, 'SoilQuality': soil_quality, 'FarmerEdu': farmer_edu,
                      'Region': region, 'Income': income, 'AdoptTech': adopt_tech})

# Dataset 2: Panel Milk Yield (panel data)
n_farms = 50
years = np.arange(2018, 2023)
n2 = n_farms * len(years)
farm_ids = np.repeat(np.arange(1, n_farms+1), len(years))
year = np.tile(years, n_farms)
breed = np.random.binomial(1, 0.5, n_farms)
breed_panel = np.repeat(breed, len(years))
farmer_age = np.repeat(np.round(np.random.normal(45, 8, n_farms)), len(years))
feed = np.round(np.random.normal(18, 3, n2))
vet_visits = np.random.poisson(3, n2)
rainfall = np.round(np.random.normal(900, 100, n2))
adoptai_prob = 1 / (1 + np.exp(-(-1 + 0.05*feed + 0.2*breed_panel)))
adopt_ai = np.random.binomial(1, adoptai_prob)
milk_yield = (10 + 0.5*feed + 0.8*breed_panel + 0.3*vet_visits + 0.01*rainfall +
              1.5*adopt_ai + 0.02*farmer_age + np.random.normal(0, 2, n2))

agri2 = pd.DataFrame({'FarmID': farm_ids, 'Year': year, 'MilkYield': milk_yield, 'Feed': feed,
                      'VetVisits': vet_visits, 'Breed': breed_panel, 'FarmerAge': farmer_age,
                      'AdoptAI': adopt_ai, 'Rainfall': rainfall})

# Save datasets for reference
agri1.to_csv("agri1.csv", index=False)
agri2.to_csv("agri2.csv", index=False)

# 2. PRACTICALS -----------------------------------------------

# UNIT 1: Classical Linear Regression
# 1. Regress Yield on Fertilizer, Irrigation, SeedRate, SoilQuality
model1 = smf.ols('Yield ~ Fertilizer + Irrigation + SeedRate + C(SoilQuality)', data=agri1).fit()
print(model1.summary())

# 2. Diagnostic plots
sm.graphics.plot_regress_exog(model1, "Fertilizer")
plt.show()
sm.qqplot(model1.resid, line='s')
plt.show()

# 3. MilkYield ~ Feed + VetVisits + Breed
model2 = smf.ols('MilkYield ~ Feed + VetVisits + C(Breed)', data=agri2).fit()
print(model2.summary())

# UNIT 2: Multicollinearity
# 1. Correlation matrix
print(agri1[['Fertilizer','Irrigation','SeedRate']].corr())

# 2. VIF
X = sm.add_constant(agri1[['Fertilizer','Irrigation','SeedRate']])
vif_df = pd.DataFrame()
vif_df["VIF"] = [variance_inflation_factor(X.values, i) for i in range(X.shape[1])]
vif_df["variable"] = X.columns
print(vif_df)

# 3. Add FertIrrig and check VIF
agri1['FertIrrig'] = agri1['Fertilizer'] + 0.8*agri1['Irrigation']
X2 = sm.add_constant(agri1[['Fertilizer','Irrigation','SeedRate','FertIrrig']])
vif_df2 = pd.DataFrame()
vif_df2["VIF"] = [variance_inflation_factor(X2.values, i) for i in range(X2.shape[1])]
vif_df2["variable"] = X2.columns
print(vif_df2)

# UNIT 3: Heteroscedasticity
# 1. Residuals vs fitted
plt.scatter(model1.fittedvalues, model1.resid)
plt.xlabel('Fitted values'); plt.ylabel('Residuals')
plt.title('Residuals vs Fitted')
plt.show()

# 2. Breusch-Pagan and White tests
bp_test = het_breuschpagan(model1.resid, model1.model.exog)
print("Breusch-Pagan p-value:", bp_test[1])
white_test = het_white(model1.resid, model1.model.exog)
print("White test p-value:", white_test[1])

# 3. Log transformation
model1_log = smf.ols('np.log(Yield) ~ Fertilizer + Irrigation + SeedRate + C(SoilQuality)', data=agri1).fit()
plt.scatter(model1_log.fittedvalues, model1_log.resid)
plt.xlabel('Fitted values (log)'); plt.ylabel('Residuals')
plt.title('Residuals vs Fitted (log model)')
plt.show()

# UNIT 4: Autocorrelation
# 1. Residuals by year for a farm
farm1 = agri2[agri2['FarmID']==1]
model3 = smf.ols('MilkYield ~ Feed + VetVisits + Year', data=farm1).fit()
plt.plot(farm1['Year'], model3.resid, marker='o')
plt.xlabel('Year'); plt.ylabel('Residuals')
plt.title('Residuals by Year (Farm 1)')
plt.show()

# 2. Durbin-Watson
print("Durbin-Watson:", durbin_watson(model3.resid))

# 3. Simulate AR(1) errors for one farm
n = len(farm1)
rho = 0.7
e = np.zeros(n)
e[0] = np.random.normal()
for t in range(1, n):
    e[t] = rho * e[t-1] + np.random.normal()
milk_yield_ar1 = (10 + 0.5*farm1['Feed'].values + 0.8*farm1['Breed'].values +
                  0.3*farm1['VetVisits'].values + e)
ar1_model = sm.OLS(milk_yield_ar1, sm.add_constant(
    np.column_stack([farm1['Feed'], farm1['VetVisits'], farm1['Breed']]))).fit()
print(ar1_model.summary())

# UNIT 5: Model Misspecification
# 1. Omitted variable
model4 = smf.ols('Yield ~ Fertilizer', data=agri1).fit()
print(model4.summary())

# RESET test (Ramsey)
from statsmodels.stats.diagnostic import linear_reset
reset = linear_reset(model4, power=2, use_f=True)
print("RESET test p-value:", reset.pvalue)

# 2. Omit Feed in MilkYield
model5 = smf.ols('MilkYield ~ VetVisits + C(Breed)', data=agri2).fit()
print(model5.summary())

# 3. Quadratic term for Fertilizer
model6 = smf.ols('Yield ~ Fertilizer + I(Fertilizer**2) + Irrigation + SeedRate + C(SoilQuality)', data=agri1).fit()
print(model6.summary())

# UNIT 6: Other Issues
# 1. Outliers and leverage
influence = OLSInfluence(model1)
plt.stem(influence.hat_matrix_diag)
plt.title("Leverage")
plt.show()
plt.stem(influence.cooks_distance[0])
plt.title("Cook's Distance")
plt.show()

# 2. Simulate missing values
agri1_na = agri1.copy()
agri1_na.loc[np.random.choice(agri1_na.index, 10, replace=False), 'Yield'] = np.nan
imputer = SimpleImputer(strategy='mean')
agri1_na['Yield_imp'] = imputer.fit_transform(agri1_na[['Yield']])

# 3. Non-normality
sns.histplot(model1.resid, kde=True)
plt.title("Histogram of Residuals")
plt.show()
from scipy.stats import shapiro
print("Shapiro-Wilk p-value:", shapiro(model1.resid)[1])

# UNIT 7: Qualitative Variables
# 1. Region and SoilQuality as dummies
model7 = smf.ols('Yield ~ Fertilizer + Irrigation + SeedRate + C(SoilQuality) + C(Region)', data=agri1).fit()
print(model7.summary())

# 2. Breed and AdoptAI in MilkYield
model8 = smf.ols('MilkYield ~ Feed + VetVisits + C(Breed) + C(AdoptAI)', data=agri2).fit()
print(model8.summary())

# 3. Logit for AdoptTech
logit1 = Logit(agri1['AdoptTech'], sm.add_constant(agri1[['FarmerEdu','Income']])).fit()
print(logit1.summary())

# UNIT 8: Simultaneous Equation Models
# 1. Simultaneous system: Yield and AdoptTech (2SLS)
# First stage: Predict AdoptTech using exogenous variables
from statsmodels.api import add_constant
exog_vars = ['Fertilizer','Irrigation','SeedRate','SoilQuality','FarmerEdu']
first_stage = smf.ols('AdoptTech ~ Fertilizer + Irrigation + SeedRate + SoilQuality + FarmerEdu', data=agri1).fit()
agri1['AdoptTech_hat'] = first_stage.fittedvalues

# Second stage: 2SLS for Yield
iv = IV2SLS(dependent=agri1['Yield'],
            exog=add_constant(agri1[['Fertilizer','Irrigation','SeedRate','SoilQuality']]),
            endog=agri1['AdoptTech'],
            instruments=agri1['AdoptTech_hat']).fit()
print(iv.summary)

# 2. Identification: Check order condition (by hand, see assignment)

# Save datasets (if needed)
agri1.to_csv("agri1.csv", index=False)
agri2.to_csv("agri2.csv", index=False)
